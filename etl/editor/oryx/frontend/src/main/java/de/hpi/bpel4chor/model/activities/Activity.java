package de.hpi.bpel4chor.model.activities;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import de.hpi.bpel4chor.model.Container;
import de.hpi.bpel4chor.model.GraphicalObject;
import de.hpi.bpel4chor.model.Swimlane;
import de.hpi.bpel4chor.model.connections.Transition;
import de.hpi.bpel4chor.model.supporting.Loop;
import de.hpi.bpel4chor.util.Output;

/**
 * An activity is a graphical object that can be connected with transitions.
 * Activities are located in processes or sub-processes.
 */
public abstract class Activity extends GraphicalObject{

	private String name = null;
	private String suppressJoinFailure = null;
	private Loop loop = null;
	private Swimlane parentSwimlane = null;
	private Container parentContainer = null;
	
	private boolean generated = false;
	
	protected List<Transition> sourceFor = new ArrayList<Transition>();
	protected List<Transition> targetFor = new ArrayList<Transition>();
	
	/**
	 * Constructor. Initializes the activity and generates a unique id.
	 * 
	 * @param output The output to print errors to.
	 */
	protected Activity(Output output) {
		super(output);
	}
	
	/**
	 * Constructor. Initializes the activity and generates a unique id.
	 * This constructor should only be used 
	 * 
	 * @param generated True, if the activity is generated by the transformation
	 * and not parsed from the input.
	 * @param output    The output to print errors to.
	 */
	protected Activity(boolean generated, Output output) {
		super(output);
		this.generated = generated; 
	}
	
	/**
	 * Constructor. Initializes the activity and generates a unique id.
	 * 
	 * @param id     The id of the activity.
	 * @param name   The name of the activity.
	 */
	protected Activity(String id, String name) {
		super(id);
		this.name = name;
	}
	
	/**
	 * Determines if the activity is a receiving activity. Receiving activities
	 * are message triggered start or intermediate events or receive tasks. 
	 * 
	 * @return True, if the activity is a receiving activity, false otherwise.
	 */
	public boolean isReceiving() {
		if ((this instanceof ServiceTask) || (this instanceof ReceiveTask)) {
			return true;
		} else if (this instanceof StartEvent) {
			if (((StartEvent)this).getTriggerType().
					equals(StartEvent.TRIGGER_MESSAGE)) {
				return true;
			}
		} else if (this instanceof IntermediateEvent) {
			if (((IntermediateEvent)this).getTriggerType().
					equals(IntermediateEvent.TRIGGER_MESSAGE)) {
				return true;
			}
		}
		return false;
	}
	
	/**
	 * Determins the events that are attached to this activity. Events
	 * can be attached to tasks or block-activities. If the given trigger 
	 * type is not null, only events with the given trigger are considered.
	 * 
	 * @param triggerType The trigger type of the attached event.
	 * 
	 * @return A list with the attached events. An empty list if no attached
	 * event was found.
	 */
	public List<IntermediateEvent> getAttachedEvents(String triggerType) {
		List<IntermediateEvent> result = 
			new ArrayList<IntermediateEvent>();
		
		for (Iterator<Activity> it = 
			this.parentContainer.getActivities().iterator(); it.hasNext();) {
			
			Activity activity = it.next();
			if (activity instanceof IntermediateEvent) {
				IntermediateEvent event = (IntermediateEvent)activity;
				if ((event.getTarget() != null) &&
						event.getTarget().equals(this)) {
					if (triggerType != null) { 
						if (event.getTriggerType().equals(triggerType)) {
							result.add(event);
						}
					} else {
						result.add(event);
					}
				}
			}
		}
		return result;
	}
	
	/**
	 * @return A list of activities that have an outgoing
	 * transition to this activity.
	 */
	public List<Activity> getPredecessors() {
		List<Activity> result = new ArrayList<Activity>();
		for (Iterator<Transition> it = 
			this.targetFor.iterator(); it.hasNext();) {
			
			Activity activity = it.next().getSource();
			if (activity != null) {
				result.add(activity);
			}
		}
		return result;
	}
	
	/**
	 * @return A list of activities that have an incoming
	 * transition from this activity.
	 */
	public List<Activity> getSuccessors() {
		List<Activity> result = new ArrayList<Activity>();
		for (Iterator<Transition> it = 
			this.sourceFor.iterator(); it.hasNext();) {
			
			Activity activity = it.next().getTarget();
			if (activity != null) {
				result.add(activity);
			}
		}
		return result;
	}

	/**
	 * @return The name of the activity.
	 */
	public String getName() {
		return this.name;
	}
	
	/**
	 * @return The loop of the activity. If the activity is not looping
	 * the result is null.
	 */
	public Loop getLoop() {
		return this.loop;
	}
	
	/**
	 * @return The swimlane the activity is located in.
	 */
	public Swimlane getParentSwimlane() {
		return this.parentSwimlane;
	}
	
	/**
	 * Sets the swimlane the activity is located in.
	 * 
	 * @param parent The new parent swimlane of the activity.
	 */
	public void setParentSwimlane(Swimlane parent) {
		this.parentSwimlane = parent;
	}
	
	/**
	 * Sets the container the activity is directly located in. 
	 * 
	 * @param parent The new parent container of the activity.
	 */
	public void setParentContainer(Container parent) {
		this.parentContainer = parent;
	}

	/**
	 * @return The list of transitions that have this activity as source
	 * (outgoing transitions).
	 */
	public List<Transition> getSourceFor() {
		return this.sourceFor;
	}
	
	/**
	 * Sets the list of transitions that have this activity as source.
	 * Already existing elements in the list will be removed.
	 * 
	 * @param sourceFor The list of transitions that have this activity as
	 * source.
	 */
	public void setSourceFor(List<Transition> sourceFor) {
		this.sourceFor = sourceFor;
	}
	
	/**
	 * Adds a transition to the list of outgoing transitions. If
	 * the target of the transition is already connected with this activity
	 * an error is added to the output.
	 * 
	 * @param transition The transition to add.
	 * @param output     The output, to print errors to.
	 */
	public void addSourceFor(Transition transition, Output output) {
		if ((getPredecessor() != null) && 
				(getPredecessor().equals(transition.getTarget()))) {
			output.addError(
					"The target of the transition " + transition.getId() + 
					" is already connected with this activity ", this.getId());
			output.addError(
					"The target of this transition " +
					" is already connected with activity "+ this.getId(),
					transition.getId());
		}
		this.sourceFor.add(transition);
	}
	
	/**
	 * Removes a transition from the list of outgoing transitions.
	 * 
	 * @param transition The transition to remove.
	 */
	public void removeSourceFor(Transition transition) {
		this.sourceFor.remove(transition);
	}

	/**
	 * @return The list of transitions that have this activity as target 
	 * (incoming transitions).
	 */
	public List<Transition> getTargetFor() {
		return this.targetFor;
	}
	
	/**
	 * Adds a transition to the list of incoming transitions. If
	 * the source of the transition is already connected with this activity
	 * an error is added to the output.
	 * 
	 * @param transition The transition to add.
	 * @param output     The output, to print errors to.
	 */
	public void addTargetFor(Transition transition, Output output) {
		if ((getSuccessor() != null) && 
				(getSuccessor().equals(transition.getSource()))) {
			output.addError(
					"The source of the transition " + transition.getId() + 
					" is already connected with this activity", this.getId());
			output.addError(
					"The source of this transition " +
					" is already connected with activity "+ this.getId(),
					transition.getId());
		}
		this.targetFor.add(transition);
	}
	
	/**
	 * Removes a transition from the list of incoming transitions.
	 * 
	 * @param transition The transition to remove.
	 */
	public void removeTargetFor(Transition transition) {
		this.targetFor.remove(transition);
	}
	
	/**
	 * @return The process or sub-process the activity is contained in.
	 */
	public Container getParentContainer() {
		return this.parentContainer;
	}
	
	/**
	 * @return Yes, if join failures should be suppressed, No otherwise. 
	 * The result is null, if the suppress join failure value is not specified.
	 */
	public String getSuppressJoinFailure() {
		return this.suppressJoinFailure;
	}
	
	/**
	 * @return The first activity that has an outgoing 
	 * transition to this activity.
	 */
	public Activity getPredecessor() {
		if (this.targetFor.size() == 1) {
			return this.targetFor.get(0).getSource();
		}
		return null;
	}
	
	/**
	 * @return The first activity that has an incoming
	 * transition from this activity.
	 */
	public Activity getSuccessor() {
		if (this.sourceFor.size() == 1) {
			return this.sourceFor.get(0).getTarget();
		}
		return null;
	}
	
	/**
	 * Determines the transition that leads from this activity
	 * to the given activity.
	 * 
	 * @param act The target activity of the transition.
	 * 
	 * @return The first transition from this activity to act.
	 */
	public Transition getTransitionTo(Activity act) {
		for (Iterator<Transition> it = 
			this.sourceFor.iterator(); it.hasNext();) {
			
			Transition transition = it.next();
			if (transition.getTarget().equals(act)) {
				return transition;
			}
		}
		return null;
	}
	
	/**
	 * Determines the transitions that leads to this activity
	 * from the given activity.
	 * 
	 * @param act The source activity of the transition.
	 * 
	 * @return The first transition from act to this activity.
	 */
	public Transition getTransitionFrom(Activity act) {
		for (Iterator<Transition> it = 
			this.targetFor.iterator(); it.hasNext();) {
			
			Transition transition = it.next();
			if (transition.getSource().equals(act)) {
				return transition;
			}
		}
		return null;
	}

	/**
	 * Sets the loop of the activity.
	 * 
	 * @param loop The new loop of the activity.
	 */
	public void setLoop(Loop loop) {
		this.loop = loop;
	}

	/**
	 * Sets the suppress join failure value for the activity.
	 * 
	 * @param suppressJoinFailure "Yes" if, join failures should be suppressed, 
	 * "No" otherwise.
	 */
	public void setSuppressJoinFailure(String suppressJoinFailure) {
		this.suppressJoinFailure = suppressJoinFailure;
	}

	/**
	 * Sets the name of the activity.
	 * 
	 * @param name The new name.
	 */
	public void setName(String name) {
		this.name = name;
	}

	/**
	 * Sets the list of incoming transitions for the activity.
	 * An already existing incoming transitions are removed.
	 * 
	 * @param targetFor The incoming transitions of the activity.
	 */
	public void setTargetFor(List<Transition> targetFor) {
		this.targetFor = targetFor;
	}

	/**
	 * @return True, if the activity was generated during the transformation,
	 * false if the activity was parsed form the input.
	 */
	public boolean isGenerated() {
		return this.generated;
	}
}
